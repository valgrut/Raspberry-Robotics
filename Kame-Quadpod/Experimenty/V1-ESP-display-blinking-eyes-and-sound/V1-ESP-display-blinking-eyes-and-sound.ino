/**************************************************************************
 This is an example for our Monochrome OLEDs based on SSD1306 drivers

 This example is for a 128x32 pixel display using I2C to communicate
 3 pins are required to interface (two I2C and one reset).
 **************************************************************************/

/*
- Verze 1
	- Ne eyeStructs - Eyes Struktury sice existuji, ale nepouzivam je.
	- Ne FreeRTOS

- Description: 
	- Oci na displei, ktere mrkaji
	- pri mrknuti delaji zvuk.
	- Kdyz se zatrese, oci se zmeni na XX.
	- Distance sensor.

- Komponenty:
	- Distance sensor
	- Buzzer
	- Display
	- Vibration sensor

*/

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <cstdlib>
#include <ctime>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels

#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define VIBRATION_SENSOR_PIN 33
#define BUZZER_PIN 32
int sensor;

#define TRIG_PIN 25
#define ECHO_PIN 26


// https://javl.github.io/image2cpp/
const unsigned char PROGMEM EYE_X[]  = {
	// 'X_symbol, 26x26px
	0x70, 0x00, 0x03, 0x80, 0xf8, 0x00, 0x07, 0xc0, 0xfc, 0x00, 0x0f, 0xc0, 0xfe, 0x00, 0x1f, 0xc0, 
	0x7f, 0x00, 0x3f, 0x80, 0x3f, 0x80, 0x7f, 0x00, 0x1f, 0xc0, 0xfe, 0x00, 0x0f, 0xe1, 0xfc, 0x00, 
	0x07, 0xf3, 0xf8, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0xff, 0xc0, 0x00, 
	0x00, 0x7f, 0x80, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x01, 0xff, 0xe0, 0x00, 
	0x03, 0xff, 0xf0, 0x00, 0x07, 0xf3, 0xf8, 0x00, 0x0f, 0xe1, 0xfc, 0x00, 0x1f, 0xc0, 0xfe, 0x00, 
	0x3f, 0x80, 0x7f, 0x00, 0x7f, 0x00, 0x3f, 0x80, 0xfe, 0x00, 0x1f, 0xc0, 0xfc, 0x00, 0x0f, 0xc0, 
	0xf8, 0x00, 0x07, 0xc0, 0x70, 0x00, 0x03, 0x80
};

const unsigned char PROGMEM epd_bitmap[] = {
	// 'bg,f8f8f8-flat,750x,075,f-pad,750x1000,f8f8f8, 128x32px
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 
	0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 
	0xff, 0xfe, 0x60, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x3c, 0x7d, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xf9, 0xff, 
	0xff, 0xe2, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0x98, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xff, 
	0xff, 0x70, 0x00, 0x5d, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xff, 0xc0, 0x07, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x7f, 
	0xff, 0x80, 0x37, 0x77, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xfc, 0x01, 0xbb, 0xbb, 0x30, 0x00, 0x07, 
	0xe0, 0x01, 0xff, 0xfc, 0x00, 0x40, 0xbf, 0xff, 0xff, 0xf9, 0x07, 0x00, 0x7f, 0xff, 0x80, 0x0f, 
	0xf0, 0x02, 0xdd, 0xd8, 0x00, 0x38, 0x3f, 0xff, 0xff, 0xfe, 0x06, 0x00, 0x3f, 0xfd, 0xc0, 0x3f, 
	0xfe, 0x0f, 0xff, 0xf0, 0x03, 0x1e, 0x7f, 0xff, 0xff, 0xfe, 0x38, 0x00, 0x0f, 0xff, 0xf0, 0x3f, 
	0xfe, 0x1f, 0x7f, 0xe0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0xf8, 0x00, 0x07, 0xff, 0xf0, 0x7f, 
	0xff, 0x0f, 0xff, 0xc0, 0x04, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x07, 0xff, 0xd8, 0x7f, 
	0xff, 0x0f, 0xff, 0xc0, 0x08, 0x17, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x3b, 0xff, 0xd0, 0x7f, 
	0xff, 0x0b, 0xff, 0x80, 0x0e, 0x27, 0xff, 0xff, 0xff, 0xff, 0xec, 0x00, 0x3b, 0xff, 0xf0, 0xff, 
	0xff, 0x8f, 0xff, 0x80, 0x00, 0x27, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x66, 0x01, 0xff, 0xf0, 0xff, 
	0xff, 0x8f, 0xff, 0x88, 0x66, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x7b, 0x01, 0xff, 0xe0, 0xff, 
	0xff, 0x87, 0xff, 0x9b, 0x7c, 0x13, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x7f, 0x01, 0xff, 0xe1, 0xff, 
	0xff, 0xc7, 0xff, 0x9b, 0x3c, 0x13, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x3e, 0x01, 0xff, 0xe1, 0xff, 
	0xff, 0xc7, 0xff, 0x9b, 0x98, 0x37, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x1c, 0x01, 0xff, 0xc3, 0xff, 
	0xff, 0xe3, 0xff, 0xdd, 0x80, 0x37, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xcb, 0x01, 0xff, 0xc3, 0xff, 
	0xff, 0xe3, 0xff, 0xcc, 0x80, 0x37, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x67, 0x03, 0xff, 0x87, 0xff, 
	0xff, 0xf3, 0xff, 0xce, 0x7a, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x3c, 0x43, 0xff, 0x8f, 0xff, 
	0xff, 0xf9, 0xff, 0xe0, 0x7f, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xfc, 0xc7, 0xff, 0x1f, 0xff, 
	0xff, 0xfd, 0xff, 0xf0, 0x7f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x83, 0xcf, 0xff, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x80, 0x9f, 0xfe, 0xbf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// struct EyeShape {};

// struct EyeShapeSquare : EyeShape
// {
//   private:
//     u_int width;
//     u_int height;
//     u_int corner_radius;
// };

// struct EyeShapeCircle : EyeShape
// {
//   private:
//     u_int radius;

//   public:
//     EyeShapeCircle(u_int radius)
//     {
//       radius = radius;
//     }
// };

// struct Eye
// {
//   private:
//     u_int pos_x;
//     u_int pos_y;
//     struct EyeShape eyeShape;
  
//   public:
//     Eye(u_int pos_x, u_int pos_y, struct EyeShape eyeShape)
//     {
//       pos_x = pos_x;
//       pos_y = pos_y;
//       eyeShape = eyeShape;
//     }

//     void draw()
//     {
//       // display.drawCircle(pos_x, pos_y, this->eyeShape.radius, SSD1306_WHITE);
//       display.drawCircle(pos_x, pos_y, 13, SSD1306_WHITE);
//       display.display();
//       delay(1);
//     }
// };



bool shake_detected = false;

// Keep the default position, so each random change will be zeroed after each iteration.
int eye1_pos_x = display.width()/2 - 13 - 2;
int eye2_pos_x = display.width()/2 + 13 + 2;
int eye1_pos_y = display.height()/2;
int eye2_pos_y = display.height()/2;



void setup()
{
  Serial.begin(9600);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Error: Don't proceed, loop forever.
  }

  // Clear the buffer
  display.clearDisplay();

  // const u_int dis_x = display.width();
  // const u_int dis_y = display.height();

  // u_int eyesSpace = 10;
  // u_int eyeRadius = 13;
  // u_int screenCenter_x = dis_x / 2;
  // u_int screenCenter_y = dis_y / 2;
  // struct EyeShapeCircle circleEye(eyeRadius);
  // struct Eye eyeLeft(screenCenter_x - eyeRadius - eyesSpace/2, screenCenter_y, circleEye);
  // struct Eye eyeRight(screenCenter_x + eyeRadius + eyesSpace/2, screenCenter_y, circleEye);


  // BUZZER_PIN initialisation
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(VIBRATION_SENSOR_PIN, INPUT);

  // distance sensor initialisation
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
}


void loop() 
{
  sensor = analogRead(VIBRATION_SENSOR_PIN);
  Serial.printf("Vibration value: %d\n", sensor);

  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN,  HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  const unsigned long duration = pulseIn(ECHO_PIN, HIGH);
  int distance= duration/29/2;
  if(duration==0)
  {
    Serial.println("Warning: no pulse from sensor");
  }  
  else
  {
    Serial.print("distance to nearest object:");
    Serial.println(distance);
    Serial.println(" cm");
  }

  if(sensor < 4095)
  {
    shake_detected = true;
  }

  if(!shake_detected)
  {
    look_straight();
  }
  else
  {
    display.clearDisplay();
    display.drawBitmap(
      eye1_pos_x,
      eye1_pos_y/2,
      EYE_X, 
      26, 26, 
      1);
    display.drawBitmap(
      eye2_pos_x,
      eye2_pos_y/2,
      EYE_X, 
      26, 26, 
      1);
    display.display();
    delay(2000);  // While shaking, keep this eyes
    shake_detected = false;
  }
}


void look_straight()
{ 
  // for(int i = 0; i < 20; i += 1) 
  // {
    display.clearDisplay();

    int rand_x = (rand() % 10) + 1 - 5;
    int rand_y = (rand() % 10) + 1 - 5;
    int rand_time = (rand() % 400) + 1 + 400;
    int rand_blink = (rand() % 3);

    display.drawCircle(eye1_pos_x + rand_x, eye1_pos_y + rand_y, 13, SSD1306_WHITE);
    display.drawCircle(eye2_pos_x + rand_x, eye2_pos_y + rand_y, 13, SSD1306_WHITE);
    display.fillCircle(eye1_pos_x + rand_x, eye1_pos_y + rand_y, 13, SSD1306_INVERSE);
    display.fillCircle(eye2_pos_x + rand_x, eye2_pos_y + rand_y, 13, SSD1306_INVERSE);

    display.display();
    delay(rand_time);

    if(rand_blink == 0)
    {
      // blink() {  # nebo jeste lip eyeLeft.blink()
      display.clearDisplay();
      display.drawLine(eye1_pos_x -12 + rand_x, eye1_pos_y + rand_y, eye1_pos_x +12 + rand_x, eye1_pos_y + rand_y, SSD1306_WHITE);
      display.drawLine(eye2_pos_x -12 + rand_x, eye2_pos_y + rand_y, eye2_pos_x +12 + rand_x, eye2_pos_y + rand_y, SSD1306_WHITE);
      display.display();

      // Random range of sounds so it is not annoying.
      int blink_sound = (rand() % 20) + 490;
      tone(BUZZER_PIN, blink_sound);  // Make sound when blinked
      delay(3);
      noTone(BUZZER_PIN);

      delay(300);
      // }
    }
    
    // if(rand_blink == 1)
    // {
    //   display.clearDisplay();
    //   display.drawBitmap(
    //     (display.width()  - 128 ) / 2,
    //     (display.height() - 32) / 2,
    //     epd_bitmap, 128, 32, 1);
    //   display.display();
    //   delay(1000);
    // }
  // }
}

